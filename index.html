<!DOCTYPE html>

<!-- 
Can I add gravity to an object on screen e.g. Circle?

 -->

<html>
	<head>
		<meta charset="utf-8" />
		<title>Moon Lander</title>
		<link rel="shortcut icon" href="favicon.png" type="image/x-icon" />
		<!-- Welcome to ZIM at https://zimjs.com - Code Creativity!                              -->
		<!-- ZIM runs on the HTML Canvas powered by JavaScript and CreateJS https://createjs.com -->
		<!-- Founded by Inventor Dan Zen - http://danzen.com - Canadian New Media Award Winner   -->
		<!-- ZIM is free to use. You can donate to help improve ZIM at https://zimjs.com/donate  -->

		<link
			href="https://fonts.googleapis.com/css?family=Courier+Prime&display=swap"
			rel="stylesheet"
		/>

		<script src="https://zimjs.org/cdn/1.2.4/createjs.js"></script>
		<script src="https://zimjs.org/cdn/10.8.0/zim.js"></script>
		<!-- use zimjs.com/distill for minified individual functions! -->

		<!-- import Box2D and ZIM Physics helper -->
		<script src="https://zimjs.org/cdn/Box2dWeb-2.1.a.3.min.js"></script>
		<script src="https://zimjs.org/cdn/physics_2.0.js"></script>

		<script>
			// SCALING OPTIONS
			// scaling can have values as follows with full being the default
			// "fit"	sets canvas and stage to dimensions and scales to fit inside window size
			// "outside"	sets canvas and stage to dimensions and scales to fit outside window size
			// "full"	sets stage to window size with no scaling
			// "tagID"	add canvas to HTML tag of ID - set to dimensions if provided - no scaling

			const scaling = 'full' // this will resize to fit inside the screen dimensions
			const width = 1000
			const height = 1000
			const color = '#25272B' // ZIM colors like green, blue, pink, faint, clear, etc.
			const outerColor = '#25272B' // any HTML colors like "violet", "#333", etc. are fine to use

			const path = 'images/'
			const assets = [
				'lander.png',
				'apollo.png',
				'rover-body.png',
				'rover-wheel-front.png',
				'rover-wheel-back.png',
				'hud-lander.png'
			]

			const frame = new Frame(
				scaling,
				width,
				height,
				color,
				outerColor,
				assets,
				path
			)
			frame.on('ready', () => {
				const stage = frame.stage
				let stageW = frame.width
				let stageH = frame.height

				// see https://zimjs.com/learn.html for video and code tutorials
				// see https://zimjs.com/docs.html for documentation
				// see https://zimjs.com/bits.html for 64 Interactive Media techniques

				// put your code here (you can delete this sample code)
				const MAXFUEL = 1000
				const ENGINE_TORQUE = 10
				const GRAVITY = 1.62
				const THRUST = GRAVITY * 0.4

				let isGameOver = false
				let isDocked = true
				let isLanded = false
				let velocityY = '0000' // You're seeing this crazy code because that's how I was able to provide 4 digit place on the canvas :D JS can take care of the type conversion
				let velocityX = 0
				let distance = '0000'
				let score = '0000'

				// WORLD
				const tile = new Tile({
					obj: new Circle({ min: 3, max: 6 }, ['#C4CCD6']),
					cols: 30,
					rows: 10,
					spacingH: 500,
					spacingV: 500
				})

				const world = new Container(tile.width, tile.height).center()
				tile.addTo(world)

				// PHYSICS GLOBAL RULES
				const physics = new Physics({
					gravity: GRAVITY,
					scroll: true,
					borders: new Boundary(0, 0, tile.width, tile.height)
				})
				// physics.debug()

				// ============================ SCORE
				let fuel = MAXFUEL
				STYLE = {
					type: {
						Label: {
							size: 18,
							font: 'Courier Prime',
							fontOptions: 'bold',
							color: 'rgba(255,255,255,0.8)'
						}
					}
				}
				let scoreBoard = new Container(stageW, 75).center().pos(0, 40)
				// .outline()
				// FUEL
				let fuelLabel = new Label({
					text: fuel
				})
					.centerReg(scoreBoard)
					.pos(50, 0, RIGHT)
				new Label({
					text: 'Fuel',
					fontOptions: 'normal',
					color: 'rgba(255,255,255,0.4)'
				})
					.centerReg(scoreBoard)
					.pos(130, 0, RIGHT)

				// VELOCITY
				let velocityLabel = new Label({
					text: velocityY
				})
					.centerReg(scoreBoard)
					.pos(50, 25, RIGHT)
				new Label({
					text: 'Velocity:y',
					fontOptions: 'normal',
					color: 'rgba(255,255,255,0.4)'
				})
					.centerReg(scoreBoard)
					.pos(130, 25, RIGHT)

				// DISTANCE
				let distanceLabel = new Label({
					text: distance
				})
					.centerReg(scoreBoard)
					.pos(50, 50, RIGHT)
				new Label({
					text: 'Distance',
					fontOptions: 'normal',
					color: 'rgba(505,255,255,0.4)'
				})
					.centerReg(scoreBoard)
					.pos(130, 50, RIGHT)

				// SCORECARD
				let scoreLabel = new Label({
					text: score,
					color: '#212121',
					backgroundColor: '#F8D59C'
				})
					.centerReg(scoreBoard)
					.pos(50, 75, RIGHT)
				new Label({
					text: 'SCORE',
					fontOptions: 'normal',
					color: 'rgba(505,255,255,0.4)'
				})
					.centerReg(scoreBoard)
					.pos(130, 85, RIGHT)

				// SCORE ICON
				new asset('hud-lander.png')
					.centerReg(scoreBoard)
					.sca(0.6)
					.pos(290, 0, RIGHT)
				new Rectangle(3, scoreBoard.height, '#888C93')
					.centerReg(scoreBoard)
					.pos(260, 0, RIGHT)

				// ======================= Moon
				const moon = new Rectangle({
					width: tile.width,
					height: stageH / 2,
					color: '#888C93'
				})
					.centerReg(world)
					.pos(0, 0, false, BOTTOM)
					.addPhysics({ categoryBits: 2, density: 1000 })

				// GENERATE RANDOM TRIANGLES - OBSTACLES
				for (let i = 0; i < 4; i++) {
					new Triangle({
						a: rand(30, 100),
						b: rand(5, 35),
						c: -1,
						color: '#888C93'
					})
						.centerReg(world)
						.pos(rand(100, tile.width), stageH / 2, false, BOTTOM)
						.addPhysics({ categoryBits: 2, density: 100 })

					new Circle({
						radius: rand(1, 5),
						color: '#888C93'
					})
						.centerReg(world)
						.pos(rand(100, tile.width), stageH / 2, false, BOTTOM)
						.addPhysics({ categoryBits: 2, density: 0.5 })
				}
				// physics.join(obstacle, moon, null, null, null, null, 'weld')
				// GENERATE RANDOM TINY STONES - DUST
				for (let i = 0; i < 50; i++) {
					new Circle({
						radius: rand(0.2, 5),
						color: '#888C93'
					})
						.centerReg(world)
						.pos(rand(100, tile.width), stageH / 2, false, BOTTOM)
						.addPhysics({
							categoryBits: 2,
							density: 0.2,
							friction: 0.2,
							restitution: 1.2
						})
				}

				// const moon = new Squiggle({
				// 	points: 12,
				// 	// points:
				// 	// 	'M.5,228.5l30-25s32,9,45,12,96-31,96-31l134,44,50-64,94,51s106,5,119,0,231,13,231,13l105-32h292l154,95s68-142,78-142,412,93,412,93l115,27,83-95,310,83,139-81,313,10,136,44,135-10h84',
				// 	thickness: 10,
				// 	controlType: 'none',
				// 	lockControlType: true,
				// 	lockControls: true
				// })
				// 	.centerReg(world)
				// 	.pos(0, -100, false, BOTTOM)
				// 	.outline()
				// 	.addPhysics({ categoryBits: 2 })
				// new asset('moon-surface.svg').centerReg(moon)
				// =========== APOLLO COMMAND MODULE
				const apollo = new Container(235, 84)
					.centerReg(world)
					.pos(null, tile.height / 3)
					.addPhysics({ dynamic: false, categoryBits: 2 })
				const mainSpaceCraft = new asset('apollo.png').centerReg(apollo)
				const apolloDockingPoint = new Circle(7, '#F8D59C')
					.centerReg(apollo)
					.pos(-5, null, true)

				// ==================== LANDER
				const lander = new Container(166, 109)
					.centerReg(world)
					.pos(tile.width / 2 + 95, tile.height / 3 - 15)
					.rot(-90)
					.addPhysics({
						dynamic: false,
						friction: 0.6,
						linear: 0.7,
						restitution: 1,
						density: 0.5,
						maskBits: 2
					})
				const spaceCraft = new asset('lander.png').centerReg(lander)
				const landerDockingPoint = new Rectangle(38, 4, '#F8D59C')
					.centerReg(lander)
					.pos(null, 0)

				// physics.join(lander, apollo)

				// =============== PARTICLES
				// MAIN ENGINE PARTICLES
				var particles = new Emitter({
					obj: [new Circle(12, null, 'white')],
					gravity: 2,
					force: 2,
					interval: 30,
					decayTime: 500,
					life: 500,
					angle: 90,
					startPaused: true
				})
					.centerReg(lander)
					.pos(null, -60, false, TOP)
				// SECONDARY ENGINES PARTICLES
				var particlesRight = new Emitter({
					obj: [new Circle(4, null, 'white')],
					gravity: 2,
					force: 2,
					interval: 30,
					decayTime: 500,
					life: 500,
					angle: -20,
					startPaused: true
				})
					.centerReg(lander)
					.pos(-40, -50, LEFT, BOTTOM)
				var particlesLeft = new Emitter({
					obj: [new Circle(4, null, 'white')],
					gravity: 2,
					force: 2,
					interval: 30,
					decayTime: 500,
					life: 500,
					angle: -180,
					startPaused: true
				})
					.centerReg(lander)
					.pos(-40, -50, RIGHT, BOTTOM)
				// lander.outline()
				// ====================== ROVER PARTS

				const roverBody = asset('rover-body.png')
					.centerReg(world)
					.mov(-25, -46)
					.alp(1)
					.addPhysics({
						restitution: 1,
						friction: 0.5,
						density: 0.3
						// dynamic: false
					})

				const frontWheel = asset('rover-wheel-front.png')
					.centerReg(world)
					.alp(1)
					.addPhysics({
						shape: 'circle',
						restitution: 0.5,
						friction: 8,
						density: 1.5,
						angular: 0.8
						// dynamic: false
					})
				const backWheel = asset('rover-wheel-back.png')
					.centerReg(world)
					.mov(-60, null)
					.alp(1)
					.addPhysics({
						shape: 'circle',
						restitution: 0.5,
						friction: 8,
						density: 1.5,
						angular: 0.8
						// dynamic: false
					})

				// ASSEMBLE ROVER
				physics.join(
					frontWheel,
					roverBody,
					null,
					null,
					null,
					null,
					'revolute'
				)
				physics.join(
					backWheel,
					roverBody,
					null,
					null,
					null,
					null,
					'revolute'
				)
				// ATTACH ROVER TO LANDER AND RELEASE ONCE LANDER IS ON THE MOON
				// physics.join(
				// 	frontWheel,
				// 	lander,
				// 	null,
				// 	null,
				// 	null,
				// 	null,
				// 	'revolute'
				// )

				// ============== HIT TEST
				let hitCheck = false
				lander.contact(obj => {
					hitCheck = true

					console.log(obj)
					if (obj.type == 'Rectangle' && velocityY < 15) {
						moon.color = '#4CC67B'
					} else if (
						obj.type == 'Rectangle' &&
						velocityY > 15 &&
						velocityY < 50
					) {
						moon.color = '#F7D33B'
					} else if (obj.type == 'Rectangle' && velocityY > 50) {
						moon.color = '#C94646'
					}
				})
				// TICKER
				Ticker.add(() => {
					// UPDATE SCOREBOARD
					velocityLabel.text = (velocityY * 10).toFixed(0)
					distance = (moon.y - lander.y).toFixed(0)
					distanceLabel.text = distance

					// hit test between main spacecraft and lander
					if (apolloDockingPoint.hitTestRect(landerDockingPoint)) {
						// zogg('DOCKING SUCCESSFUL')
						isDocked = true
						lander.dynamic = false
						moon.color = '#888C93' // once docked change moon color to default
					}

					// Hit test if lander is on the moon
					if (lander.hitTestBounds(moon, 10)) {
						isLanded = true
					} else {
						isLanded = false
					}
					// zogg('Is lander on the moon? ' + isLanded)

					let velX = velocityX
					if (velX < 0) velX *= -1 // convert negavite values to positive

					// TO CHECK IF APOLLO AND LANDER ARE WITHIN 400 RANGE
					let xDistance = 0 // distance between apollo and lander's x positions
					if (lander.x > apollo.x) xDistance = lander.x - apollo.x
					if (lander.x < apollo.x) xDistance = apollo.x - lander.x
					let yDistance = 0 // distance between apollo and lander's y positions
					if (lander.y > apollo.y) yDistance = lander.y - apollo.y
					if (lander.y < apollo.y) yDistance = apollo.y - lander.y
					if (xDistance < 400 && yDistance < 400) {
						// zogg('Within range')
						if (velX > 5) {
							apolloDockingPoint.color = '#C94646' // RED
							landerDockingPoint.color = '#C94646'
						} else {
							apolloDockingPoint.color = '#4CC67B' // GREEN
							landerDockingPoint.color = '#4CC67B'
						}
					} else {
						apolloDockingPoint.color = '#F8D59C' // DEFAULT YELLOW
						landerDockingPoint.color = '#F8D59C'
					}
					// =========

					// zogb(velX)
					// zogg('Is Docked? ' + isDocked)
				})

				// =============== CONTROLS
				const pad = new GamePad()
				let isLanderControls = true
				let fx = 0
				let fy = 0
				pad.on('data', function(e) {
					// horizontal is 0 and vertical is 1 on left stick
					// horizontal is 2 and vertical is 3 on right stick
					// PRESS A TO RELEASE THE LANDER
					// zogb(e.buttons)
					if (e.buttons[0] == true) {
						isDocked = false
						lander.mov(10, null)
						lander.dynamic = true
						lander.torque(60)
					}

					// PRESS Y FOR IMPULSE FORCE
					// if (e.buttons[3] == true) lander.impulse(0, -40)
					if (e.buttons[3] == true) zogr(lander)

					if (isLanded) {
						// PRESS X TO DEPLOY ROVER ON THE MOON - only if lander is on the moon surface
						if (e.buttons[2] == true) {
							isLanderControls = !isLanderControls
							if (isLanderControls) {
								followTo(lander)
							} else {
								followTo(frontWheel)
							}
						}
					} else {
					}

					if (isLanderControls) {
						// Calculate Velocity
						calculateVelocity()
						if (fuel > 0) {
							// LANDER CONTROL
							if (e.axes[1] < 0) {
								fy = e.axes[1] * 100 * THRUST
							} else {
								fy = e.axes[1] * 10
							}
							lander.force(e.axes[0] * 10, fy, null, null)
							// lander.force(null, 5, 200, 200)
							lander.torque(e.axes[2] * 40)

							// PARTICLE ANIMATION TO SIMULATE ENGINE ON AND OFF STATES
							// MAIN ENGINE
							let yOffset = (e.axes[0] - e.axes[1]).toFixed(3)
							if (yOffset > 0.1) {
								particles.pauseEmitter(false)
								//
								fuel > 0 ? (fuel -= 0.5) : (fuel = 0)
								fuelLabel.text = fuel
							} else {
								particles.pauseEmitter(true)
							}
							// AUXILIARY ENGINE
							if (e.axes[2] < 0.001) {
								particlesRight.pauseEmitter(false)
							} else {
								particlesRight.pauseEmitter(true)
							}
							if (e.axes[2] > 0.1) {
								particlesLeft.pauseEmitter(false)
							} else {
								particlesLeft.pauseEmitter(true)
							}
						} else {
							// fuel exhausted turn off the engine animations
							particles.pauseEmitter(true)
							particlesRight.pauseEmitter(true)
							particlesLeft.pauseEmitter(true)
						}
					} else {
						// ====== ROVER CONTROLS
						frontWheel.torque(e.axes[2] * ENGINE_TORQUE)
						backWheel.torque(e.axes[2] * ENGINE_TORQUE)
					}

					// zogg(e.axes[1])
				})

				// ============================ FUNCTIONS
				let y1 = 0 // starting Y position
				let x1 = 0 // starting X position
				function calculateVelocity() {
					// v = distance / time
					let y2 = lander.y // current Y position
					let x2 = lander.x // current X position
					let distanceY = y2 - y1
					let distanceX = x2 - x1
					let vY = distanceY / 60
					let vX = distanceX / 60
					y1 = y2 // assign current position to old one
					x1 = x2 // assign current position to old one
					velocityY = (vY * 1000).toFixed(3)
					velocityX = (vX * 1000).toFixed(3)
					return
				}

				// FOLLOW LANDER
				followTo(lander)
				function followTo(obj) {
					frame.follow(obj)
				}

				stage.update() // this is needed to show any changes
			}) // end of ready
		</script>

		<meta name="viewport" content="width=device-width, user-scalable=no" />
	</head>

	<body>
		<!-- canvas with id="myCanvas" is made by zim Frame -->
	</body>
</html>
